var documenterSearchIndex = {"docs":
[{"location":"repository_structure/#Repository-Structure","page":"Repository Structure","title":"Repository Structure","text":"","category":"section"},{"location":"repository_structure/","page":"Repository Structure","title":"Repository Structure","text":"Pages = [\"repository_structure.md\"]","category":"page"},{"location":"repository_structure/","page":"Repository Structure","title":"Repository Structure","text":"In this section, we describe the structure of the repository. Note that the description of the functions used for running the algorithm itself are defined in the next section.","category":"page"},{"location":"repository_structure/#Root","page":"Repository Structure","title":"Root","text":"","category":"section"},{"location":"repository_structure/","page":"Repository Structure","title":"Repository Structure","text":"The root of the repository contains five files.","category":"page"},{"location":"repository_structure/","page":"Repository Structure","title":"Repository Structure","text":".gitignore: This file tells git which files to ignore when committing changes.\nLICENSE: This file contains the license for the repository. The license for this package is an MIT license. \nREADME.md: This file contains the basic description of the repository, primarily for linking to the documentation.\nProject.toml: This file contains the dependencies for the package.\nManifest.toml: This file contains the exact versions of the dependencies for the package. This together with Project.toml makes the paper results exactly reproducible.","category":"page"},{"location":"repository_structure/#.github/workflows","page":"Repository Structure","title":".github/workflows","text":"","category":"section"},{"location":"repository_structure/","page":"Repository Structure","title":"Repository Structure","text":"This folder just contains some basic workflows for testing the package and producing its documentation. These are standard files you'll see in almost any Julia package.","category":"page"},{"location":"repository_structure/#docs","page":"Repository Structure","title":"docs","text":"","category":"section"},{"location":"repository_structure/","page":"Repository Structure","title":"Repository Structure","text":"The docs folder is what produces the documentation, and produces the paper results. Within this folder, what actually produces the documentation is the make.jl file, which uses Documenter.jl and Literate.jl to run the scripts and launch the documentation. The src folders contains all the scripts for each section, which you can inspect yourself - just read the documentation and, if you do want to see the source file, either see the link at the top-right or at the bottom of the page.","category":"page"},{"location":"repository_structure/#src","page":"Repository Structure","title":"src","text":"","category":"section"},{"location":"repository_structure/","page":"Repository Structure","title":"Repository Structure","text":"The src folder is where all the code for the algorithm lives. The folder is broken into other folders, and the only file inside this folder directly is:","category":"page"},{"location":"repository_structure/","page":"Repository Structure","title":"Repository Structure","text":"StepwiseEQL.jl: This is the module that defines the package and loads in all the dependencies and the files.","category":"page"},{"location":"repository_structure/#src/structs","page":"Repository Structure","title":"src/structs","text":"","category":"section"},{"location":"repository_structure/","page":"Repository Structure","title":"Repository Structure","text":"The src/structs folder contains the definitions for all the structs used in the package:","category":"page"},{"location":"repository_structure/","page":"Repository Structure","title":"Repository Structure","text":"eql_model.jl: The definition of an EQLModel, used for producing the stepwise learning results. This struct would have a very similar definition if you were to extend to other types of problems.\neql_solution.jl: The definition of an EQLSolution, giving the results for the stepwise learning procedure.\nensemble_eql_solution.jl: If running the stepwise learning procedure for multiple initial sets of active coefficients, you obtain an EnsembleEQLSolution defined here.\naveraged_ode_solution.jl: For proliferation we average the solution over each simulation, leading to a single set of results. This average is defined as an AveragedODESolution, defined here.","category":"page"},{"location":"repository_structure/#src/function_evaluation","page":"Repository Structure","title":"src/function_evaluation","text":"","category":"section"},{"location":"repository_structure/","page":"Repository Structure","title":"Repository Structure","text":"The src/function_evaluation folder contains the files used for defining how we evaluate basis functions, and for how we compute densities and their derivatives:","category":"page"},{"location":"repository_structure/","page":"Repository Structure","title":"Repository Structure","text":"basis_functions.jl: Defines the structs for a basis function, specifically as a BasisSet or a PolynomialBasis.\ndensity_computations.jl: This contains all the functions that are used to compute densities, their derivatives, and similarly for leading edges.","category":"page"},{"location":"repository_structure/#src/problem_building","page":"Repository Structure","title":"src/problem_building","text":"","category":"section"},{"location":"repository_structure/","page":"Repository Structure","title":"Repository Structure","text":"The src/problem_building folder contains the main functions used for building up the EQLModels:","category":"page"},{"location":"repository_structure/","page":"Repository Structure","title":"Repository Structure","text":"matrix_construction.jl: The main component of the algorithm is the construction of the matrix system boldsymbol Aboldsymboltheta = boldsymbol b. The code in this file constructs the matrix boldsymbol A and the vector boldsymbol b.\npde_construction.jl: This script automatically detects the type of PDE to be built (fixed boundary, moving boundary, proliferation, etc.) and constructs it.","category":"page"},{"location":"repository_structure/#src/individual_steps","page":"Repository Structure","title":"src/individual_steps","text":"","category":"section"},{"location":"repository_structure/","page":"Repository Structure","title":"Repository Structure","text":"The src/individual_steps folder is used for performing the individual steps in our procedure:","category":"page"},{"location":"repository_structure/","page":"Repository Structure","title":"Repository Structure","text":"cross_validation.jl: This script contains the code used for creating the training and test sets if cross-validation is used for the algorithm.\ndensity_loss.jl: This script contains the functions used for evaluating the density component, and the leading edge component, of the loss function.\nevaluate_loss.jl: This script contains the functions used for evaluating the loss function completely.\nmodel_voting.jl: This script contains the functions used for incorporating and removing each term one at a time during an individual step of the algorithm, and for then making a vote on which model to step to in the next iteration.\npenalty.jl: This file contains the functions used for penalising model complexity, and also for enforcing constraints on D(q) and E(q).\nregression_loss.jl: This file contains the functions used for evaluating the regression component of the loss function.","category":"page"},{"location":"repository_structure/#src/algorithm","page":"Repository Structure","title":"src/algorithm","text":"","category":"section"},{"location":"repository_structure/","page":"Repository Structure","title":"Repository Structure","text":"The src/algorithm folder is used for actually running the algorithm, with the main script being stepwise.jl:","category":"page"},{"location":"repository_structure/","page":"Repository Structure","title":"Repository Structure","text":"stepwise.jl: This script contains the main entry point for running our stepwise procedure, defining the stepwise_selection function (described in more detail in the next section). \nrun_stepwise.jl: The stepwise_selection function from the previous point constructs an EQLModel and then runs the main internal method of stepwise_selection that actually runs all the results. This is defined in this file.\nmodel_sampling.jl: This file contains the internal function that is used for running the procedure for multiple initial conditions efficiently.","category":"page"},{"location":"repository_structure/#test","page":"Repository Structure","title":"test","text":"","category":"section"},{"location":"repository_structure/","page":"Repository Structure","title":"Repository Structure","text":"This folder is just for testing the algorithm's implementation itself. It is a bit lengthy and unlikely to be very readable, so you should not be overly concerned about it. If you did want to test the function, you can run ","category":"page"},{"location":"repository_structure/","page":"Repository Structure","title":"Repository Structure","text":"julia> ] test","category":"page"},{"location":"repository_structure/","page":"Repository Structure","title":"Repository Structure","text":"assuming the StepwiseEQL package is activated; you can tell if it is by seeing if, after typing ] test inside the Julia REPL without executing it, you see","category":"page"},{"location":"repository_structure/","page":"Repository Structure","title":"Repository Structure","text":"(StepwiseEQL) pkg> test","category":"page"},{"location":"algorithm/","page":"The Algorithm","title":"The Algorithm","text":"CurrentModule = StepwiseEQL","category":"page"},{"location":"algorithm/#The-Algorithm","page":"The Algorithm","title":"The Algorithm","text":"","category":"section"},{"location":"algorithm/","page":"The Algorithm","title":"The Algorithm","text":"Pages = [\"algorithm.md\"]","category":"page"},{"location":"algorithm/","page":"The Algorithm","title":"The Algorithm","text":"In this section, we describe the functions used for actually running the algorithm. Here we only describe how to run the results after obtaining a CellProblem. If you want to know more about setting up the CellProblems, or solving any PDEs, please see:","category":"page"},{"location":"algorithm/","page":"The Algorithm","title":"The Algorithm","text":"EpithelialDynamics1D.jl: This is the package that actually implements the discrete model of the epithelial dynamics. Please see its documentation for detailed information and examples.\nFiniteVolumeMethod1D.jl: This is the package that solves the PDEs on a fixed boundary. Please see its documentation for detailed information and examples.\nMovingBoundaryProblems1D.jl: This is the package that solves the PDEs on a moving boundary. Please see its documentation for detailed information and examples.","category":"page"},{"location":"algorithm/#Basis-Functions","page":"The Algorithm","title":"Basis Functions","text":"","category":"section"},{"location":"algorithm/","page":"The Algorithm","title":"The Algorithm","text":"The functions below are used for defining basis functions:","category":"page"},{"location":"algorithm/","page":"The Algorithm","title":"The Algorithm","text":"BasisSet \nPolynomialBasis","category":"page"},{"location":"algorithm/#StepwiseEQL.BasisSet","page":"The Algorithm","title":"StepwiseEQL.BasisSet","text":"BasisSet{F<:Tuple} <: Function\n\nA set of basis functions. \n\nFields\n\nbases::F: A Tuple of basis functions, each function being of the form (q, p) -> Number, with the same p for each basis function.\n\nConstructors\n\nBasisSet((f1, f2, ...))\nBasisSet(f1, f2, ...)\n\nEvaluating\n\nYou can evaluate a BasisSet using the method\n\n(f::BasisSet{F})(q, θ, p) where {F}\n\nwhich returns \n\nsum_i=1^n theta_if_i(q p)\n\n\n\n\n\n","category":"type"},{"location":"algorithm/#StepwiseEQL.PolynomialBasis","page":"The Algorithm","title":"StepwiseEQL.PolynomialBasis","text":"PolynomialBasis(d1, d2)\n\nConstruct a set of polynomial basis functions of degree d1 to d2,  returning a BasisSet object.\n\nExamples\n\njulia> basis = PolynomialBasis(2, 4);\n\njulia> basis(0.5, [0.1, 0.67, -2.3], nothing)\n-0.034999999999999976\n\njulia> 0.1 * 0.5^2 + 0.67 * 0.5^3 - 2.3 * 0.5^4\n-0.034999999999999976\n\n\n\n\n\n","category":"function"},{"location":"algorithm/","page":"The Algorithm","title":"The Algorithm","text":"For example, the basis set q q^2 q^3 can be defined in two ways:","category":"page"},{"location":"algorithm/","page":"The Algorithm","title":"The Algorithm","text":"using StepwiseEQL\nf1 = (q, p) -> q \nf2 = (q, p) -> q^2 \nf3 = (q, p) -> q^3 \nB = BasisSet(f1, f2, f3)","category":"page"},{"location":"algorithm/","page":"The Algorithm","title":"The Algorithm","text":"B = PolynomialBasis(1, 3)","category":"page"},{"location":"algorithm/","page":"The Algorithm","title":"The Algorithm","text":"The reason for the second argument p is in case you want to give better control of the scaling on the basis function's coefficients. For example, the basis set aq bq^-2 cq^3 can be defined as:","category":"page"},{"location":"algorithm/","page":"The Algorithm","title":"The Algorithm","text":"f1 = (q, p) -> p.a * q \nf2 = (q, p) -> p.b * q^(-2)\nf3 = (q, p) -> p.c * q^3\nB = BasisSet(f1, f2, f3)","category":"page"},{"location":"algorithm/","page":"The Algorithm","title":"The Algorithm","text":"and you would then provide p when evaluating B, for example:","category":"page"},{"location":"algorithm/","page":"The Algorithm","title":"The Algorithm","text":"p = (a = 2.0, b = 3.0, c = 5.0) # same p for each basis function\nB(0.2, [0.3, 0.5, 1], p)","category":"page"},{"location":"algorithm/","page":"The Algorithm","title":"The Algorithm","text":"which returns theta_1aq + theta_2bq^-2 + theta_3cq^3 with theta_1 = 03, theta_2 = 05, theta_3 = 1, a = 2, b = 3, and c = 5.","category":"page"},{"location":"algorithm/#Averaging-ODE-Solutions","page":"The Algorithm","title":"Averaging ODE Solutions","text":"","category":"section"},{"location":"algorithm/","page":"The Algorithm","title":"The Algorithm","text":"Usually averaging over multiple realisations from the discrete model can be handled internally by the stepwise function, but you may want to re-average for the purpose of plotting (as we do in case studies 3 and 4). For this reason, we provide AveragedODESolution as an exported function that you can use:","category":"page"},{"location":"algorithm/","page":"The Algorithm","title":"The Algorithm","text":"AveragedODESolution","category":"page"},{"location":"algorithm/#StepwiseEQL.AveragedODESolution","page":"The Algorithm","title":"StepwiseEQL.AveragedODESolution","text":"AveragedODESolution{K,S}\n\nStruct representing a cell simulation averaged over many simulations. \n\nFields\n\nu::K\n\nThese are the knots, storing the knots using for interpolating the solutions  at each time, where u[j] the knots for the jth time. \n\nt::Vector{Float64}\n\nThe vector of times.\n\nq::Vector{Vector{Float64}}\n\nThe averaged densities, with q[j] the averaged density at time t[j] and  at the corresponding knots in u[j].\n\ncell_sol::S\n\nThe original cell simulation.\n\nConstructor\n\nYou can construct an AveragedODESolution using the following method:\n\nAveragedODESolution(\n    sol::EnsembleSolution, \n    num_knots=100, \n    indices=eachindex(sol), \n    interp_fnc=LinearInterpolation, \n    stat=mean, \n    extrapolate=true\n)\n\nNote that the arguments are positional arguments, not keyword arguments.\n\nArguments\n\nsol\n\nThe ensemble of cell solutions.\n\nnum_knots\n\nThe number of knots to use in the interpolant for averaging the cell solutions.  Defaults to 100.\n\nindices\n\nThe indices of the simulations to consider for averaging. Defaults to all simulations.\n\ninterp_fnc\n\nA function of the form (u, t) that is used for averaging.  Defaults to linear interpolation from DataInterpolations.jl.\n\nstat\n\nThis should be a function, or a Tuple of two functions with one for each endpoint, that decides the range to use  for the knots at each time step. Defaults to mean,  meaning the knots for a given time will span between a and b, where a is the average left-most cell position over each  simulation at that time, and b is the average right-most cell position over each simulation at that time. If, for example, stat were (minimum, maximum), then the minimum and maximum end-positions would be used for a and b, respectively,  at the corresponding time.\n\nextrapolate=true\n\nWhether to allow for extrapolation when averaging the cell solutions. Defaults to true. If false, then when evaluating the interpolant for a given realisation and a given time, then the density for a node  is set to zero if it exceeds the right-most knot position for the given time.\n\nOutput\n\nReturns the corresponding AveragedODESolution.\n\n\n\n\n\n","category":"type"},{"location":"algorithm/#The-Stepwise-Algorithm","page":"The Algorithm","title":"The Stepwise Algorithm","text":"","category":"section"},{"location":"algorithm/","page":"The Algorithm","title":"The Algorithm","text":"The entry point into our stepwise procedure is stepwise_selection, documented in detail below.","category":"page"},{"location":"algorithm/","page":"The Algorithm","title":"The Algorithm","text":"stepwise_selection","category":"page"},{"location":"algorithm/#StepwiseEQL.stepwise_selection","page":"The Algorithm","title":"StepwiseEQL.stepwise_selection","text":"stepwise_selection(cell_sol; kwargs...)\n\nPerform stepwise selection on the given cell solution cell_sol, given as a  CellSolution from EpithelialDynamics1D.jl. In the  list of keyword arguments below, the notation (A/B/C/D)_Y, for example,  means that there are keyword arguments A_Y, B_Y, C_Y, and D_Y.\n\nThe result returned from this function will be one of:\n\nEQLSolution\n\nThis gives the solution. You can display this in the REPL to see the table of  results automatically. You can inspect the individual coefficients and other  relevant objects by inspecting the fields of the struct. For example, if  you have \n\nsol = stepwise_selection(cell_sol; kwargs...)\n\nthen sol.diffusion_theta will be the set of coefficients for the diffusion  function. You can query the full list of fields by using \n\npropertynames(sol)\n\nor typing sol.<TAB> in the REPL (<TAB> means hit tab). We also note that if you  want to have more interactivity with the table that gets displayed in the REPL, you should  look into the show method for EQLSolution, which has signature \n\nBase.show(io::IO, ::MIME\"text/plain\", eql_sol::EQLSolution;\n    step_limit=6,\n    crop=:horizontal,\n    backend=Val(:text),\n    booktabs=true,\n    show_votes=false,\n    show_all_loss=false,\n    crayon=Crayon(bold=true, foreground=:green),\n    latex_crayon=[\"color{blue}\", \"textbf\"],\n    transpose=true)\n\nFor example,\n\nBase.show(stdout, MIME\"text/plain\"(), sol; show_votes=false, show_all_loss=false, transpose=true)\n\nprints the table without including the votes, only shows the complete loss function rather than also  including its individual components, and transposes the table. A LaTeX version of the table can be obtained  using backend=Val(:latex), e.g. a LaTeX version of the above could be printed using\n\nBase.show(stdout, MIME\"text/plain\"(), sol; backend=Val(:latex), show_votes=false, show_all_loss=false, transpose=true)\n\nYou can also just use \n\nlatex_table(sol; kwargs...)\n\nto get the LaTeX format printed.\n\nEnsembleEQLSolution\n\nIn this case, you have provided model_samples as a keyword argument and  model_samples > 1. This struct has four fields: solutions, which stores  all the individual EQLSolutions; final_loss, which stores a Dict mapping  final vectors of active coefficients to Tuples of the form (loss, n), where  loss is the loss function at that final model, and n is the number of times that  model was found out of the complete set of initial indicator vectors sampled;  best_model, which is an indicator vector which gives the model out of those found with the least loss; best_model_indices, which gives the indices of all solutions in solutions which had a  final indicator vector matching that of best_model.\n\nKeyword Arguments\n\n(diffusion/reaction/rhs/moving_boundary)_basis::BasisSet\n\nThe basis expansion to use for the diffusion, reaction, right-hand side, and moving boundary terms, respectively. If not provided, the functions are replaced  with the zero function. For diffusion_basis, a BasisSet is required.\n\n(diffusion/reaction/rhs/moving_boundary)_parameters\n\nThe parameters to use for evaluating the corresponding basis set. The default  is nothing.\n\n(diffusion/reaction/rhs/moving_boundary)_theta\n\nThis keyword argument indicates whether the coefficients θ used for evaluating the basis sets  are fixed or are to be learned, with a defualt of nothing. If nothing, then they will be learned. Otherwise, they should be  a vector of numbers indicating the coefficients θ to be used for the respective mechanism. For example, diffusion_theta = [1.0, 0.5] means that the diffusion function is evaluated with coefficients  θ₁ᵈ = 1 and θ₂ᵈ = 0.5.\n\nthreshold_tol\n\nThe threshold tolerances to use for pruning the matrix, with a default of a zero tolerance for each  quantity. This should be a NamedTuple if provided, only including any of the names q, x,  dt, dx, dx2, dx_bc, and dL. The q, dt, dx, and dx2 tolerances are used for pruning  the interior PDE, corresponding to tolerances based on the quantiles of q(x, t), ∂q(x, t)/∂t, ∂q(x, t)/∂x, and ∂²q(x, t)/∂x². The dx_bc tolerance is used for pruning based on ∂q(x, t)/∂t evaluated  at the boundary, and is only used for the matrix corresponding to the right-hand side boundary condition. The  dL tolerance is for dL/dt, and is only used for the matrix corresponding to the moving boundary condition.  For example, providing \n\nthreshold_tol = (q = 0.1, dL = 0.3, x = 0.7, dx = 0.1, dx_bc = 0.05)\n\nmeans that the matrix for the interior problem will only include points whose densities are between the  10% and 90% density quantiles, the 10% and 90% quantiles for ∂q(x, t)/∂x, at positions between 0 and 70% of the current leading edge for the given time. The matrix for the right-hand side boundary condition  will only include points between the 5% and 95% quantiles for ∂q(x, t)/∂x at the boundary. The matrix  for the moving boundary condition will only include points where the velocity dL/dt is between the 30%  and 70% quantiles of dL/dt.\n\nmesh_points\n\nThe number of mesh points to use for discretising the corresponding PDE. The default is 100.\n\ncross_validation\n\nWhether to use cross-validation for selecting the model. The default is false.\n\nrng\n\nThe random number generator to use. This defaults to the global RNG, Random.default_rng().\n\nskip\n\nIndices of any coefficients that should be skipped over when deciding which terms  to include or remove. By default, this is empty\n\nregression\n\nWhether to include the regression loss in the loss function. Defaults to false.\n\ndensity\n\nWhether to include the density loss in the loss function. Defaults to true.\n\ncomplexity\n\nThe complexity penalty to use for the loss function. Defaults to 1. Use 0 if you would  not like to penalise complexity.\n\nloss_function\n\nThe loss function use. Defaults to default_loss(; regression, density, complexity). The loss  function should take the same form as described in ?default_loss.\n\nbidirectional\n\nWhether to allow for steps in both directions, meaning terms can be either added or deleted at each step.  The default is true. If false, then steps can only be taken backwards.\n\ntrials\n\nIf cross_validation is true, this is the number of votes to attempt at each step of the algorithm. \n\ninitial\n\nThe initial set of active coefficients. The default is :all, meaning all terms are initially  active. If :random, then a random set of terms is initially active. If :none, then all terms are initially inactive. Otherwise, initial should be a vector of Booleans indicating the  initially active terms, with true for active and false for inactive. The indices should match  the flattened form of the coefficients, with the order of coefficients being diffusion, reaction,  rhs, and then moving_boundary. For example, if the basis functions are\n\nD(q) = θ₁ᵈϕ₁ᵈ + θ₂ᵈϕ₂ᵈ                      (diffusion)\nR(q) = θ₁ʳϕ₁ʳ + θ₂ʳϕ₂ʳ + θ₃ʳϕ₃ʳ             (reaction)\nH(q) = θ₁ʰϕ₁ʰ + θ₂ʰϕ₂ʰ + θ₃ʰϕ₃ʰ + θ₄ʰϕ₄ʰ    (rhs)\nE(q) = θ₁ᵉϕ₁ᵉ + θ₂ᵉϕ₂ᵉ                      (moving boundary)\n\nand you want to start with θ₁ᵈ, θ₁ʳ, θ₂ʳ, θ₂ʰ, and θ₂ᵉ active,  then you should provide \n\ninitial = [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1]\n\nmodel_samples\n\nHow many initial models to randomly sample when providing the results. This defaults to 1. If model_samples > 1, then initial must be :random. The result returned in this case  will be an EnsembleEQLSolution.\n\nuse_relative_err\n\nWhether to use relative error (true) or absolute error (false) in the loss function summands. Defaults  to true.\n\naggregate\n\nWhen considering an ensemble of cell solutions, aggregate=true indicates that the matrix constructed  should combine all the cell solutions into one matrix, and the loss function should be the sum of the loss functions for each cell solution. The default is false. If this is false, then for an ensemble of cell  solutions you must have average=Val(true); if both are false and the cell solution is an ensemble, the call will error. \n\ntime_range\n\nThe time range, provided as a Tuple of the form (tmin, tmax), to use for constructing the matrix.  The default is the complete time span that the cell simulation is performed over. \n\naverage\n\nWhen considering an ensemble of cell solutions, average=Val(true) indicates that the matrix constructed  should average the solutions together into a single matrix, and the loss function should use this averaged solution,  given by an AveragedODESolution. The default is Val(true). If this is Val(false), then for an ensemble of cell  solutions you must have aggregate=true; if both are false and the cell solution is an ensemble, the call will error. \n\nsimulation_indices\n\nThe simulations to consider in the matrix. Only relevant if an ensemble of cell solutions is being considered. Defaults to all simulations.\n\nnum_knots\n\nThe number of knots to use in the interpolant for averaging the cell solutions. Only relevant if an ensemble of cell solutions is being considered. Defaults to 100.\n\navg_interp_fnc\n\nA function of the form (u, t) that is used for averaging. Only relevant if an ensemble of cell solutions is being considered. Defaults to linear interpolation from DataInterpolations.jl.\n\nstat\n\nThis should be a function, or a Tuple of two functions with one for each endpoint, that decides the range to use  for the knots at each time step. Only relevant if an ensemble of cell solutions is being considered. Defaults to mean,  meaning the knots for a given time will span between a and b, where a is the average left-most cell position over each  simulation at that time, and b is the average right-most cell position over each simulation at that time. If, for example, stat were (minimum, maximum), then the minimum and maximum end-positions would be used for a and b, respectively,  at the corresponding time.\n\nshow_progress\n\nWhether to print the current step of the algorithm at each step. Defaults to true.\n\nmax_steps\n\nMaximum number of steps to allow for the algorithm. Defaults to 100.\n\nleading_edge_error\n\nWhether to include the leading edge error in the loss function. If this is true, then density must also be true. Only relevant if the cell simulation being considered is a moving boundary  problem. Defaults to true.\n\nextrapolate_pde\n\nIf the time range is smaller than the time span of the cell simulation, then setting extrapolate_pde to true means that the loss function will still consider all saved time points, not just those within the provided  time_range. The default is false.\n\nnum_constraint_checks\n\nThe number of equally-spaced nodes to use between the minimum and maximum densities for constraining the diffusion term and the moving boundary term. Defaults to 100.\n\nconserve_mass\n\nWhether to enforce conservation of mass by constraining the diffusion and moving boundary terms to be equal. Defaults to false.\n\nextrapolate_average\n\nWhether to allow for extrapolation when averaging the cell solutions. Only relevant if an ensemble of cell solutions is being considered. Defaults to true. If false, then when evaluating the interpolant for a given realisation and a given time, then the density for a node  is set to zero if it exceeds the right-most knot position for the given time.\n\ncouple_rhs\n\nWhether to couple the boundary conditions at the right-hand side and at the moving boundary together. Only relevant if the moving boundary coefficients  are fixed. If true, then the matrix for the right-hand boundary condition will also include terms coming from the moving boundary,  replacing ∂q/∂x with the right-hand side's assumed basis expansion. Defaults to true. If false, then the matrix for the right-hand boundary condition will only include terms coming from the right-hand side.\n\n\n\n\n\n","category":"function"},{"location":"algorithm/#Printing-LaTeX-Tables","page":"The Algorithm","title":"Printing LaTeX Tables","text":"","category":"section"},{"location":"algorithm/","page":"The Algorithm","title":"The Algorithm","text":"From an EQLSolution, returned by stepwise_selection, you can print the LaTeX form of the table using latex_table:","category":"page"},{"location":"algorithm/","page":"The Algorithm","title":"The Algorithm","text":"latex_table","category":"page"},{"location":"algorithm/#StepwiseEQL.latex_table","page":"The Algorithm","title":"StepwiseEQL.latex_table","text":"latex_table(eql_sol::EQLSolution; kwargs...)\n\nPrints the EQLSolution eql_sol in LaTeX format. Keyword arguments are passed to show, which  has signature \n\nBase.show(io::IO, ::MIME\"text/plain\", eql_sol::EQLSolution;\n    step_limit=6,\n    crop=:horizontal,\n    backend=Val(:text),\n    booktabs=true,\n    show_votes=false,\n    show_all_loss=false,\n    crayon=Crayon(bold=true, foreground=:green),\n    latex_crayon=[\"color{blue}\", \"textbf\"],\n    transpose=true)\n\n(Of course, backend=Val(:latex) is passed - you cannot change that.)\n\n\n\n\n\n","category":"function"},{"location":"algorithm/#Loss-Function","page":"The Algorithm","title":"Loss Function","text":"","category":"section"},{"location":"algorithm/","page":"The Algorithm","title":"The Algorithm","text":"If you want to provide a new loss function, you can provide it as a keyword loss_function to stepwise_selection. The function that is used to construct the default loss is below for example.","category":"page"},{"location":"algorithm/","page":"The Algorithm","title":"The Algorithm","text":"default_loss","category":"page"},{"location":"algorithm/#StepwiseEQL.default_loss","page":"The Algorithm","title":"StepwiseEQL.default_loss","text":"default_loss(; kwargs...)\ndefault_loss(regression_loss, density_loss, indicators; density=true, regression=false, complexity=1)\n\nThe default loss function. The first method, accepting the same keyword arguments as in the second method, returns  a function that accepts the regression loss, density loss, and indicators, and returns the total loss, evaluated  via the second method.\n\nArguments\n\nregression_loss: The value of the regression loss.\ndensity_loss: The value of the density loss.\nindicators: A vector of Boolean values, indicating which the set of active coefficients.\n\nKeyword Arguments\n\ndensity=true: Whether to include the density loss.\nregression=false: Whether to include the regression loss.\ncomplexity=1: The complexity penalty coefficient. Use 0 to disable the complexity penalty.\n\n\n\n\n\n","category":"function"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"In the sections that follow, we give scripts that reproduce the results in the paper. The detail behind the methods used, and the interpretation of the results, can be found in the paper. The first six sections discuss the four case studies, with the first two sections reproducing Figures 2 and 3 from the paper, and then the last sections show material that we give in the supplementary material. The complete table of contents is listed below.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Overview\nPaper:\nReproducing Figure 2\nReproducing Figure 3\nCase Study 1\nCase Study 2\nCase Study 3:\nAccurate continuum limit\nInaccurate continuum limit\nCase Study 4:\nAccurate continuum limit\nInaccurate continuum limit\nSupplementary Material:\nDiscrete Densities at the Boundaries\nPiecewise Proliferation Law\nLinear Diffusion\nParameter Sensitivity Study","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install the package, you first need to install Julia. To do this:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"You can download Julia here, preferably v1.9.0 (the latest version at the time of writing). My preferred installer for Julia is juliaup.\nYou need an actual editor for Julia, e.g. VS Code with the Julia extension.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"To now actually install the package, there are two ways.","category":"page"},{"location":"installation/#Installing-from-GitHub","page":"Installation","title":"Installing from GitHub","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"The first way would be to install it as you would any other package. Within Julia, you can do:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg \nPkg.add(\"https://github.com/DanielVandH/StepwiseEQL.jl\")\nusing StepwiseEQL ","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"With this, you will have access to the functions required for running the examples in the documentation and thus reproduce the results in the paper; you will need to install the packages listed  in those examples of course. For example, typing ","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add([\"CairoMakie\", \"LinearSolve\"])\nusing CairoMakie, LinearSolve","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"will install and load CairoMakie.jl and LinearSolve.jl.","category":"page"},{"location":"installation/#Cloning-from-GitHub","page":"Installation","title":"Cloning from GitHub","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Alternatively, you could clone the repository so that you have the entire package downloaded. With this done, you could for example open the package's folder in VS Code. You can then do:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg \ncd(@__DIR__)\nPkg.activate(\".\") \nPkg.resolve()\nPkg.instantiate()\nusing StepwiseEQL ","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"This will activate the package in your REPL, and will also download all the dependencies (packages) needed for the examples.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = StepwiseEQL","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the documentation for StepwiseEQL.jl. Click here to go back to the GitHub repository.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package contains the code for the implementation of our stepwise equation learning framework introduced  in our paper ..., which has abstract:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The implementation is specific to the models of epithelial dynamics discussed in the paper, but you could  easily extend the code to other problems if you wish. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The sidebar contains the following sections:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Installation: How to install the package and run the code.\nRepository Structure: A description of the structure of the GitHub repository.\nThe Algorithm: A description of how to run the algorithm. This does not describe the algorithm itself - see the paper for this.\nPaper Results: The sections in this section reproduce all the results in the paper.","category":"page"}]
}
