<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parameter Sensitivity Study · StepwiseEQL.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/StepwiseEQL.jl/supplementary_material/parameter_sensitivity/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">StepwiseEQL.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><a class="tocitem" href="../../repository_structure/">Repository Structure</a></li><li><a class="tocitem" href="../../algorithm/">The Algorithm</a></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">Paper Results</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../overview/">Overview</a></li><li><a class="tocitem" href="../../case_studies/figure_2/">Reproducing Figure 2</a></li><li><a class="tocitem" href="../../case_studies/figure_3/">Reproducing Figure 3</a></li><li><a class="tocitem" href="../../case_studies/cs1/">Case Study 1</a></li><li><a class="tocitem" href="../../case_studies/cs2/">Case Study 2</a></li><li><input class="collapse-toggle" id="menuitem-5-6" type="checkbox"/><label class="tocitem" for="menuitem-5-6"><span class="docs-label">Case Study 3</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../case_studies/cs3a/">Accurate continuum limit</a></li><li><a class="tocitem" href="../../case_studies/cs3b/">Inaccurate continuum limit</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Case Study 4</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../case_studies/cs4a/">Accurate continuum limit</a></li><li><a class="tocitem" href="../../case_studies/cs4b/">Inaccurate continuum limit</a></li></ul></li><li><a class="tocitem" href="../new_density/">Discrete Densities at the Boundaries</a></li><li><a class="tocitem" href="../piecewise_prof/">A Piecewise Proliferation Law</a></li><li><a class="tocitem" href="../linear_diffusion/">Linear Diffusion</a></li><li class="is-active"><a class="tocitem" href>Parameter Sensitivity Study</a><ul class="internal"><li><a class="tocitem" href="#Just-the-code"><span>Just the code</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Paper Results</a></li><li class="is-active"><a href>Parameter Sensitivity Study</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Parameter Sensitivity Study</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/StepwiseEQL.jl/tree/main/docs/src/literate_supplementary_material/parameter_sensitivity.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>This example is also available as a Jupyter notebook: <a href="https://github.com/DanielVandH/StepwiseEQL.jl/tree/main/docs/src/supplementary_material/notebooks/parameter_sensitivity.ipynb"><code>parameter_sensitivity.ipynb</code></a></p></div></div><h1 id="Parameter-Sensitivity-Study"><a class="docs-heading-anchor" href="#Parameter-Sensitivity-Study">Parameter Sensitivity Study</a><a id="Parameter-Sensitivity-Study-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Sensitivity-Study" title="Permalink"></a></h1><p>In this section, we show how we performed our parameter sensitivity study given in the supplementary material of the paper. For this study, we use the problem for <a href="../case_studies/cs3b.html">Case Study 3 in the case that the continuum limit is inaccurate</a>. We set up this problem below.</p><pre><code class="language-julia hljs">using StepwiseEQL
using CairoMakie
using EpithelialDynamics1D
using OrdinaryDiffEq
using Random
using Setfield
final_time = 75.0
domain_length = 30.0
midpoint = domain_length / 2
initial_condition = [LinRange(0, 5, 30); LinRange(25, 30, 30)] |&gt; unique!
damping_constant = 1.0
resting_spring_length = 0.2
spring_constant = 1 / 5
k = spring_constant
force_law_parameters = (s=resting_spring_length, k=spring_constant)
force_law = (δ, p) -&gt; p.k * (p.s - δ)
Δt = 1e-2
K = 15.0
β = 0.15
G = (δ, p) -&gt; p.β * (one(δ) - inv(p.K * δ))
Gp = (β=β, K=K)
prob = CellProblem(;
    final_time,
    initial_condition,
    damping_constant,
    force_law,
    force_law_parameters,
    proliferation_law=G,
    proliferation_period=Δt,
    proliferation_law_parameters=Gp);</code></pre><p>The following function will be used for solving <code>ens_prob</code>.</p><pre><code class="language-julia hljs">function solve_problem(prob; saveat=0.1, trajectories=1000, final_time=75.0)
    prob = @set prob.final_time = final_time
    ens_prob = EnsembleProblem(prob)
    return solve(ens_prob, Tsit5(), EnsembleThreads(); saveat, trajectories) # multithreading ⟹ not deterministic
end</code></pre><p>The function below solves the equation learning problem and also returns the loss. We also extract the learned vectors.</p><pre><code class="language-julia hljs">const diffusion_basis = PolynomialBasis(-1, -3)
const reaction_basis = PolynomialBasis(1, 5)
function solve_eql_problem(esol::EnsembleSolution; num_knots=200, τq=0.25)
    eql_sol = stepwise_selection(esol; diffusion_basis, reaction_basis,
        threshold_tol=(q=τq,), num_knots=num_knots, initial=:none, show_progress=true, max_steps=10)
    return eql_sol, eql_sol.loss_history[end], eql_sol.diffusion_theta, eql_sol.reaction_theta
end</code></pre><p>Now that we have our functions, we need to solve the problem for a large combination of parameters. We could do an extremely large combination, taking into account all the parameters, but this leads to a combinatorial issue. Instead, we vary parameters one at a time, using as default the values that led to a good result in the paper. The following ranges are what we use.</p><pre><code class="language-julia hljs">base_saveat = 0.1
base_trajectories = 1000
base_num_knots = 200
base_τq = 0.25
base_final_time = 75.0
n = 25
saveat = LinRange(0.1, 1.0, n)
trajectories = round.(Int, LinRange(10, 1000, n))
final_time = LinRange(1.0, 100.0, n)
num_knots = round.(Int, LinRange(10, 250, n))
τq = LinRange(0, 0.49, n)</code></pre><pre><code class="nohighlight hljs">25-element LinRange{Float64, Int64}:
 0.0, 0.0204167, 0.0408333, 0.06125, 0.0816667, 0.102083, 0.1225, …, 0.3675, 0.387917, 0.408333, 0.42875, 0.449167, 0.469583, 0.49</code></pre><p>Now we define the function that performs the study.</p><pre><code class="language-julia hljs">function perform_study(saveat, trajectories, final_time, num_knots, τq,
    base_saveat, base_trajectories, base_final_time, base_num_knots, base_τq)
    n = length(saveat)
    @assert n == length(trajectories) == length(final_time) == length(num_knots) == length(τq)
    loss = zeros(n, 5)
    diffusion_theta = Matrix{Vector{Float64}}(undef, n, 5)
    reaction_theta = Matrix{Vector{Float64}}(undef, n, 5)
    base_esol = solve_problem(prob; saveat=base_saveat, trajectories=base_trajectories, final_time=base_final_time)
    for i in axes(loss, 1) # 1:n
        @info &quot;Starting loop $i: Solving esol_saveat&quot;
        esol_saveat = solve_problem(prob; saveat=saveat[i], trajectories=base_trajectories, final_time=base_final_time)
        @info &quot;Starting loop $i: Solving esol_trajectories&quot;
        esol_trajectories = solve_problem(prob; saveat=base_saveat, trajectories=trajectories[i], final_time=base_final_time)
        @info &quot;Starting loop $i: Solving esol_final_time&quot;
        esol_final_time = solve_problem(prob; saveat=base_saveat, trajectories=base_trajectories, final_time=final_time[i])
        @info &quot;Starting loop $i: Solving eql_sol_saveat&quot;
        eql_sol_saveat = solve_eql_problem(esol_saveat; num_knots=base_num_knots, τq=base_τq)
        @info &quot;Starting loop $i: Solving eql_sol_trajectories&quot;
        eql_sol_trajectories = solve_eql_problem(esol_trajectories; num_knots=base_num_knots, τq=base_τq)
        @info &quot;Starting loop $i: Solving eql_sol_final_time&quot;
        eql_sol_final_time = solve_eql_problem(esol_final_time; num_knots=base_num_knots, τq=base_τq)
        @info &quot;Starting loop $i: Solving eql_sol_num_knots&quot;
        eql_sol_num_knots = solve_eql_problem(base_esol; num_knots=num_knots[i], τq=base_τq)
        @info &quot;Starting loop $i: Solving eql_sol_τq&quot;
        eql_sol_τq = solve_eql_problem(base_esol; num_knots=base_num_knots, τq=τq[i])
        loss[i, 1], diffusion_theta[i, 1], reaction_theta[i, 1] = eql_sol_saveat[2], eql_sol_saveat[3], eql_sol_saveat[4]
        loss[i, 2], diffusion_theta[i, 2], reaction_theta[i, 2] = eql_sol_trajectories[2], eql_sol_trajectories[3], eql_sol_trajectories[4]
        loss[i, 3], diffusion_theta[i, 3], reaction_theta[i, 3] = eql_sol_final_time[2], eql_sol_final_time[3], eql_sol_final_time[4]
        loss[i, 4], diffusion_theta[i, 4], reaction_theta[i, 4] = eql_sol_num_knots[2], eql_sol_num_knots[3], eql_sol_num_knots[4]
        loss[i, 5], diffusion_theta[i, 5], reaction_theta[i, 5] = eql_sol_τq[2], eql_sol_τq[3], eql_sol_τq[4]
        GC.gc(true)
    end
    return loss, diffusion_theta, reaction_theta
end</code></pre><p>Finally, we perform the actual study. For the interest of time, we have already saved the results below, but if you like you can delete that file so that <code>perform_study</code> runs.</p><pre><code class="language-julia hljs">using JLD2
file = joinpath(@__DIR__, &quot;study_data.jld2&quot;)
if isfile(file)
    loss, diffusion_theta, reaction_theta = load(file, &quot;loss&quot;, &quot;diffusion_theta&quot;, &quot;reaction_theta&quot;)
else
    loss, diffusion_theta, reaction_theta = perform_study(saveat, trajectories, final_time, num_knots, τq,
        base_saveat, base_trajectories, base_final_time, base_num_knots, base_τq)
    jldsave(file; loss, diffusion_theta, reaction_theta)
end
loss</code></pre><pre><code class="nohighlight hljs">25×5 Matrix{Float64}:
 -1.41202    0.218977  -1.28605     0.0485026   0.157787
 -1.48509    0.223239  -0.542106    0.145979    0.150478
 -1.50792    0.171062  -0.294267   -2.33106     0.148175
 -1.58726    0.499913  -0.116057    0.171795    0.146162
 -1.37637   -0.665585   0.0777995  -1.52556     0.146085
  ⋮
 -0.801099  -0.869353   0.104088   -1.21078     0.381131
 -1.81567   -1.32082    0.0839524   0.201087    0.324
 -1.71785   -1.17208    0.0397615  -0.630834    0.409037
 -1.67509   -1.38896   -0.121978    0.0910703  -0.232934</code></pre><p>Let us now visualise the results.</p><pre><code class="language-julia hljs">saveat_loss, trajectories_loss, final_time_loss, num_knots_loss, τq_loss = eachcol(loss)
diffθ_iszero = all.(iszero, diffusion_theta)
saveat_zerodiffθ, trajectories_zerodiffθ, final_time_zerodiffθ, num_knots_zerodiffθ, τq_zerodiffθ = eachcol(diffθ_iszero)
fig = Figure(fontsize=44)
ax1 = Axis(fig[1, 1], xlabel=L&quot;h&quot;, ylabel=L&quot;\mathcal{L}(\mathbf{\theta})&quot;,
    title=L&quot;(a): $h$&quot;, titlealign=:left, width=600, height=400,
    xticks=(0:0.2:1, [L&quot;%$s&quot; for s in 0:0.2:1]),
    yticks=(-1.5:0.5:0.5, [L&quot;%$s&quot; for s in -1.5:0.5:0.5]))
ax2 = Axis(fig[1, 2], xlabel=L&quot;n_s&quot;, ylabel=L&quot;\mathcal{L}(\mathbf{\theta})&quot;,
    title=L&quot;(b): $n_s$&quot;, titlealign=:left, width=600, height=400,
    xticks=(0:200:1000, [L&quot;%$s&quot; for s in 0:200:1000]),
    yticks=(-2:0.5, [L&quot;%$s&quot; for s in -2:0.5]))
ax3 = Axis(fig[1, 3], xlabel=L&quot;t_M&quot;, ylabel=L&quot;\mathcal{L}(\mathbf{\theta})&quot;,
    title=L&quot;(c): $t_M$&quot;, titlealign=:left, width=600, height=400,
    xticks=(0:25:100, [L&quot;%$s&quot; for s in 0:25:100]),
    yticks=(-2:0.5, [L&quot;%$s&quot; for s in -2:0.5]))
ax4 = Axis(fig[2, 1], xlabel=L&quot;n_k&quot;, ylabel=L&quot;\mathcal{L}(\mathbf{\theta})&quot;,
    title=L&quot;(d): $n_k$&quot;, titlealign=:left, width=600, height=400,
    xticks=(0:50:250, [L&quot;%$s&quot; for s in 0:50:250]),
    yticks=(-2:0.5, [L&quot;%$s&quot; for s in -2:0.5]))
ax5 = Axis(fig[2, 2], xlabel=L&quot;\tau_q&quot;, ylabel=L&quot;\mathcal{L}(\mathbf{\theta})&quot;,
    title=L&quot;(e): $\tau_q$&quot;, titlealign=:left, width=600, height=400,
    xticks=(0:0.1:0.5, [L&quot;%$s&quot; for s in 0:0.1:0.5]),
    yticks=(-2:0.5, [L&quot;%$s&quot; for s in -2:0.5]))
scatter!(ax1, saveat, saveat_loss, markersize=17, color=[iszero(d) ? :red : :black for d in saveat_zerodiffθ])
scatter!(ax2, trajectories, trajectories_loss, markersize=17, color=[iszero(d) ? :red : :black for d in trajectories_zerodiffθ])
scatter!(ax3, final_time, final_time_loss, markersize=17, color=[iszero(d) ? :red : :black for d in final_time_zerodiffθ])
scatter!(ax4, num_knots, num_knots_loss, markersize=17, color=[iszero(d) ? :red : :black for d in num_knots_zerodiffθ])
scatter!(ax5, τq, τq_loss, markersize=17, color=[iszero(d) ? :red : :black for d in τq_zerodiffθ])
xlims!(ax1, 0, 0.1 + maximum(saveat))
xlims!(ax2, [-20, 20] .+ extrema(trajectories)...)
xlims!(ax3, [-1, 5] .+ extrema(final_time)...)
xlims!(ax4, [-10, 10] .+ extrema(num_knots)...)
xlims!(ax5, [-0.05, 0.05] .+ extrema(τq)...)
Legend(fig[2, 3],
    [MarkerElement(color=:red, marker=&#39;.&#39;, markersize=122),
        MarkerElement(color=:black, marker=&#39;.&#39;, markersize=122)],
    [L&quot;D(q) \neq 0&quot;, L&quot;D(q) = 0&quot;],
    halign=:left, valign=:top)
resize_to_layout!(fig)
fig</code></pre><figure>
    <img src='sfigure_sensitivity.png', alt='Figure S7 from the paper'><br>
</figure><p>We colour the points in the above figure according to whether the learned <span>$D(q)$</span> is zero. We see little sensitivity to the number of time points. The number of simulations, <span>$n_s$</span>, also does not seem to matter so much, so long as there is a sufficient number of them. The final time, <span>$t_M$</span>, seems to be impactful, with only the interval <span>$50 \leq t_M \leq 75$</span> giving reasonable results. The number of knots used for averaging, <span>$n_k$</span>, does not matter as much, so long as there are not too few. Lastly, <span>$\tau_q$</span> seems to be the most important parameter, with reasonable results only obtained for <span>$\tau_q \approx 0.25$</span>.</p><h2 id="Just-the-code"><a class="docs-heading-anchor" href="#Just-the-code">Just the code</a><a id="Just-the-code-1"></a><a class="docs-heading-anchor-permalink" href="#Just-the-code" title="Permalink"></a></h2><p>An uncommented version of this example is given below. You can view the source code for this file <a href="https://github.com/DanielVandH/StepwiseEQL.jl/tree/main/docs/src/literate_supplementary_material/parameter_sensitivity.jl">here</a>.</p><pre><code class="language-julia hljs">using StepwiseEQL
using CairoMakie
using EpithelialDynamics1D
using OrdinaryDiffEq
using Random
using Setfield
final_time = 75.0
domain_length = 30.0
midpoint = domain_length / 2
initial_condition = [LinRange(0, 5, 30); LinRange(25, 30, 30)] |&gt; unique!
damping_constant = 1.0
resting_spring_length = 0.2
spring_constant = 1 / 5
k = spring_constant
force_law_parameters = (s=resting_spring_length, k=spring_constant)
force_law = (δ, p) -&gt; p.k * (p.s - δ)
Δt = 1e-2
K = 15.0
β = 0.15
G = (δ, p) -&gt; p.β * (one(δ) - inv(p.K * δ))
Gp = (β=β, K=K)
prob = CellProblem(;
    final_time,
    initial_condition,
    damping_constant,
    force_law,
    force_law_parameters,
    proliferation_law=G,
    proliferation_period=Δt,
    proliferation_law_parameters=Gp)

function solve_problem(prob; saveat=0.1, trajectories=1000, final_time=75.0)
    prob = @set prob.final_time = final_time
    ens_prob = EnsembleProblem(prob)
    return solve(ens_prob, Tsit5(), EnsembleThreads(); saveat, trajectories) # multithreading ⟹ not deterministic
end;

const diffusion_basis = PolynomialBasis(-1, -3)
const reaction_basis = PolynomialBasis(1, 5)
function solve_eql_problem(esol::EnsembleSolution; num_knots=200, τq=0.25)
    eql_sol = stepwise_selection(esol; diffusion_basis, reaction_basis,
        threshold_tol=(q=τq,), num_knots=num_knots, initial=:none, show_progress=true, max_steps=10)
    return eql_sol, eql_sol.loss_history[end], eql_sol.diffusion_theta, eql_sol.reaction_theta
end;

base_saveat = 0.1
base_trajectories = 1000
base_num_knots = 200
base_τq = 0.25
base_final_time = 75.0
n = 25
saveat = LinRange(0.1, 1.0, n)
trajectories = round.(Int, LinRange(10, 1000, n))
final_time = LinRange(1.0, 100.0, n)
num_knots = round.(Int, LinRange(10, 250, n))
τq = LinRange(0, 0.49, n)

function perform_study(saveat, trajectories, final_time, num_knots, τq,
    base_saveat, base_trajectories, base_final_time, base_num_knots, base_τq)
    n = length(saveat)
    @assert n == length(trajectories) == length(final_time) == length(num_knots) == length(τq)
    loss = zeros(n, 5)
    diffusion_theta = Matrix{Vector{Float64}}(undef, n, 5)
    reaction_theta = Matrix{Vector{Float64}}(undef, n, 5)
    base_esol = solve_problem(prob; saveat=base_saveat, trajectories=base_trajectories, final_time=base_final_time)
    for i in axes(loss, 1) # 1:n
        @info &quot;Starting loop $i: Solving esol_saveat&quot;
        esol_saveat = solve_problem(prob; saveat=saveat[i], trajectories=base_trajectories, final_time=base_final_time)
        @info &quot;Starting loop $i: Solving esol_trajectories&quot;
        esol_trajectories = solve_problem(prob; saveat=base_saveat, trajectories=trajectories[i], final_time=base_final_time)
        @info &quot;Starting loop $i: Solving esol_final_time&quot;
        esol_final_time = solve_problem(prob; saveat=base_saveat, trajectories=base_trajectories, final_time=final_time[i])
        @info &quot;Starting loop $i: Solving eql_sol_saveat&quot;
        eql_sol_saveat = solve_eql_problem(esol_saveat; num_knots=base_num_knots, τq=base_τq)
        @info &quot;Starting loop $i: Solving eql_sol_trajectories&quot;
        eql_sol_trajectories = solve_eql_problem(esol_trajectories; num_knots=base_num_knots, τq=base_τq)
        @info &quot;Starting loop $i: Solving eql_sol_final_time&quot;
        eql_sol_final_time = solve_eql_problem(esol_final_time; num_knots=base_num_knots, τq=base_τq)
        @info &quot;Starting loop $i: Solving eql_sol_num_knots&quot;
        eql_sol_num_knots = solve_eql_problem(base_esol; num_knots=num_knots[i], τq=base_τq)
        @info &quot;Starting loop $i: Solving eql_sol_τq&quot;
        eql_sol_τq = solve_eql_problem(base_esol; num_knots=base_num_knots, τq=τq[i])
        loss[i, 1], diffusion_theta[i, 1], reaction_theta[i, 1] = eql_sol_saveat[2], eql_sol_saveat[3], eql_sol_saveat[4]
        loss[i, 2], diffusion_theta[i, 2], reaction_theta[i, 2] = eql_sol_trajectories[2], eql_sol_trajectories[3], eql_sol_trajectories[4]
        loss[i, 3], diffusion_theta[i, 3], reaction_theta[i, 3] = eql_sol_final_time[2], eql_sol_final_time[3], eql_sol_final_time[4]
        loss[i, 4], diffusion_theta[i, 4], reaction_theta[i, 4] = eql_sol_num_knots[2], eql_sol_num_knots[3], eql_sol_num_knots[4]
        loss[i, 5], diffusion_theta[i, 5], reaction_theta[i, 5] = eql_sol_τq[2], eql_sol_τq[3], eql_sol_τq[4]
        GC.gc(true)
    end
    return loss, diffusion_theta, reaction_theta
end;

using JLD2
file = joinpath(@__DIR__, &quot;study_data.jld2&quot;)
if isfile(file)
    loss, diffusion_theta, reaction_theta = load(file, &quot;loss&quot;, &quot;diffusion_theta&quot;, &quot;reaction_theta&quot;)
else
    loss, diffusion_theta, reaction_theta = perform_study(saveat, trajectories, final_time, num_knots, τq,
        base_saveat, base_trajectories, base_final_time, base_num_knots, base_τq)
    jldsave(file; loss, diffusion_theta, reaction_theta)
end
loss

saveat_loss, trajectories_loss, final_time_loss, num_knots_loss, τq_loss = eachcol(loss)
diffθ_iszero = all.(iszero, diffusion_theta)
saveat_zerodiffθ, trajectories_zerodiffθ, final_time_zerodiffθ, num_knots_zerodiffθ, τq_zerodiffθ = eachcol(diffθ_iszero)
fig = Figure(fontsize=44)
ax1 = Axis(fig[1, 1], xlabel=L&quot;h&quot;, ylabel=L&quot;\mathcal{L}(\mathbf{\theta})&quot;,
    title=L&quot;(a): $h$&quot;, titlealign=:left, width=600, height=400,
    xticks=(0:0.2:1, [L&quot;%$s&quot; for s in 0:0.2:1]),
    yticks=(-1.5:0.5:0.5, [L&quot;%$s&quot; for s in -1.5:0.5:0.5]))
ax2 = Axis(fig[1, 2], xlabel=L&quot;n_s&quot;, ylabel=L&quot;\mathcal{L}(\mathbf{\theta})&quot;,
    title=L&quot;(b): $n_s$&quot;, titlealign=:left, width=600, height=400,
    xticks=(0:200:1000, [L&quot;%$s&quot; for s in 0:200:1000]),
    yticks=(-2:0.5, [L&quot;%$s&quot; for s in -2:0.5]))
ax3 = Axis(fig[1, 3], xlabel=L&quot;t_M&quot;, ylabel=L&quot;\mathcal{L}(\mathbf{\theta})&quot;,
    title=L&quot;(c): $t_M$&quot;, titlealign=:left, width=600, height=400,
    xticks=(0:25:100, [L&quot;%$s&quot; for s in 0:25:100]),
    yticks=(-2:0.5, [L&quot;%$s&quot; for s in -2:0.5]))
ax4 = Axis(fig[2, 1], xlabel=L&quot;n_k&quot;, ylabel=L&quot;\mathcal{L}(\mathbf{\theta})&quot;,
    title=L&quot;(d): $n_k$&quot;, titlealign=:left, width=600, height=400,
    xticks=(0:50:250, [L&quot;%$s&quot; for s in 0:50:250]),
    yticks=(-2:0.5, [L&quot;%$s&quot; for s in -2:0.5]))
ax5 = Axis(fig[2, 2], xlabel=L&quot;\tau_q&quot;, ylabel=L&quot;\mathcal{L}(\mathbf{\theta})&quot;,
    title=L&quot;(e): $\tau_q$&quot;, titlealign=:left, width=600, height=400,
    xticks=(0:0.1:0.5, [L&quot;%$s&quot; for s in 0:0.1:0.5]),
    yticks=(-2:0.5, [L&quot;%$s&quot; for s in -2:0.5]))
scatter!(ax1, saveat, saveat_loss, markersize=17, color=[iszero(d) ? :red : :black for d in saveat_zerodiffθ])
scatter!(ax2, trajectories, trajectories_loss, markersize=17, color=[iszero(d) ? :red : :black for d in trajectories_zerodiffθ])
scatter!(ax3, final_time, final_time_loss, markersize=17, color=[iszero(d) ? :red : :black for d in final_time_zerodiffθ])
scatter!(ax4, num_knots, num_knots_loss, markersize=17, color=[iszero(d) ? :red : :black for d in num_knots_zerodiffθ])
scatter!(ax5, τq, τq_loss, markersize=17, color=[iszero(d) ? :red : :black for d in τq_zerodiffθ])
xlims!(ax1, 0, 0.1 + maximum(saveat))
xlims!(ax2, [-20, 20] .+ extrema(trajectories)...)
xlims!(ax3, [-1, 5] .+ extrema(final_time)...)
xlims!(ax4, [-10, 10] .+ extrema(num_knots)...)
xlims!(ax5, [-0.05, 0.05] .+ extrema(τq)...)
Legend(fig[2, 3],
    [MarkerElement(color=:red, marker=&#39;.&#39;, markersize=122),
        MarkerElement(color=:black, marker=&#39;.&#39;, markersize=122)],
    [L&quot;D(q) \neq 0&quot;, L&quot;D(q) = 0&quot;],
    halign=:left, valign=:top)
resize_to_layout!(fig)
fig</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../linear_diffusion/">« Linear Diffusion</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 22 August 2023 00:29">Tuesday 22 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
