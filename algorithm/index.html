<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The Algorithm · StepwiseEQL.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/StepwiseEQL.jl/algorithm/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">StepwiseEQL.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../repository_structure/">Repository Structure</a></li><li class="is-active"><a class="tocitem" href>The Algorithm</a><ul class="internal"><li><a class="tocitem" href="#Basis-Functions"><span>Basis Functions</span></a></li><li><a class="tocitem" href="#Averaging-ODE-Solutions"><span>Averaging ODE Solutions</span></a></li><li><a class="tocitem" href="#The-Stepwise-Algorithm"><span>The Stepwise Algorithm</span></a></li><li><a class="tocitem" href="#Printing-LaTeX-Tables"><span>Printing LaTeX Tables</span></a></li><li><a class="tocitem" href="#Loss-Function"><span>Loss Function</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Paper Results</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../case_studies/figure_2/">Reproducing Figure 2</a></li><li><a class="tocitem" href="../case_studies/figure_3/">Reproducing Figure 3</a></li><li><a class="tocitem" href="../case_studies/cs1/">Case Study 1</a></li><li><a class="tocitem" href="../case_studies/cs2/">Case Study 2</a></li><li><input class="collapse-toggle" id="menuitem-5-6" type="checkbox"/><label class="tocitem" for="menuitem-5-6"><span class="docs-label">Case Study 3</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../case_studies/cs3a/">Accurate continuum limit</a></li><li><a class="tocitem" href="../case_studies/cs3b/">Inaccurate continuum limit</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Case Study 4</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../case_studies/cs4a/">Accurate continuum limit</a></li><li><a class="tocitem" href="../case_studies/cs4b/">Inaccurate continuum limit</a></li></ul></li><li><a class="tocitem" href="../supplementary_material/new_density/">Discrete Densities at the Boundaries</a></li><li><a class="tocitem" href="../supplementary_material/piecewise_prof/">A Piecewise Proliferation Law</a></li><li><a class="tocitem" href="../supplementary_material/linear_diffusion/">Linear Diffusion</a></li><li><a class="tocitem" href="../supplementary_material/parameter_sensitivity/">Parameter Sensitivity Study</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>The Algorithm</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The Algorithm</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/StepwiseEQL.jl/blob/main/docs/src/algorithm.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="The-Algorithm"><a class="docs-heading-anchor" href="#The-Algorithm">The Algorithm</a><a id="The-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#The-Algorithm" title="Permalink"></a></h1><ul><li><a href="#The-Algorithm">The Algorithm</a></li><li class="no-marker"><ul><li><a href="#Basis-Functions">Basis Functions</a></li><li><a href="#Averaging-ODE-Solutions">Averaging ODE Solutions</a></li><li><a href="#The-Stepwise-Algorithm">The Stepwise Algorithm</a></li><li><a href="#Printing-LaTeX-Tables">Printing LaTeX Tables</a></li><li><a href="#Loss-Function">Loss Function</a></li></ul></li></ul><p>In this section, we describe the functions used for actually running the algorithm. Here we only describe how to run the results after obtaining a <code>CellProblem</code>. If you want to know more about setting up the <code>CellProblem</code>s, or solving any PDEs, please see:</p><ul><li><a href="https://github.com/DanielVandH/EpithelialDynamics1D.jl">EpithelialDynamics1D.jl</a>: This is the package that actually implements the discrete model of the epithelial dynamics. Please see its <a href="https://danielvandh.github.io/EpithelialDynamics1D.jl/stable/">documentation</a> for detailed information and examples.</li><li><a href="https://github.com/DanielVandH/FiniteVolumeMethod1D.jl">FiniteVolumeMethod1D.jl</a>: This is the package that solves the PDEs on a fixed boundary. Please see its <a href="https://danielvandh.github.io/FiniteVolumeMethod1D.jl/stable/">documentation</a> for detailed information and examples.</li><li><a href="https://github.com/DanielVandH/FiniteVolumeMethod1D.jl">MovingBoundaryProblems1D.jl</a>: This is the package that solves the PDEs on a moving boundary. Please see its <a href="https://danielvandh.github.io/MovingBoundaryProblems1D.jl/stable/">documentation</a> for detailed information and examples.</li></ul><h2 id="Basis-Functions"><a class="docs-heading-anchor" href="#Basis-Functions">Basis Functions</a><a id="Basis-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Basis-Functions" title="Permalink"></a></h2><p>The functions below are used for defining basis functions:</p><article class="docstring"><header><a class="docstring-binding" id="StepwiseEQL.BasisSet" href="#StepwiseEQL.BasisSet"><code>StepwiseEQL.BasisSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BasisSet{F&lt;:Tuple} &lt;: Function</code></pre><p>A set of basis functions. </p><p><strong>Fields</strong></p><ul><li><code>bases::F</code>: A <code>Tuple</code> of basis functions, each function being of the form <code>(q, p) -&gt; Number</code>, with the same <code>p</code> for each basis function.</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">BasisSet((f1, f2, ...))
BasisSet(f1, f2, ...)</code></pre><p><strong>Evaluating</strong></p><p>You can evaluate a <code>BasisSet</code> using the method</p><pre><code class="nohighlight hljs">(f::BasisSet{F})(q, θ, p) where {F}</code></pre><p>which returns </p><p class="math-container">\[\sum_{i=1}^n \theta_if_i(q, p)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/StepwiseEQL.jl/blob/1f3d0c965dd65a7f068318eede96b4b4625557c7/src/function_evaluation/basis_functions.jl#L6-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StepwiseEQL.PolynomialBasis" href="#StepwiseEQL.PolynomialBasis"><code>StepwiseEQL.PolynomialBasis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">PolynomialBasis(d1, d2)</code></pre><p>Construct a set of polynomial basis functions of degree <code>d1</code> to <code>d2</code>,  returning a <code>BasisSet</code> object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; basis = PolynomialBasis(2, 4);

julia&gt; basis(0.5, [0.1, 0.67, -2.3], nothing)
-0.034999999999999976

julia&gt; 0.1 * 0.5^2 + 0.67 * 0.5^3 - 2.3 * 0.5^4
-0.034999999999999976</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/StepwiseEQL.jl/blob/1f3d0c965dd65a7f068318eede96b4b4625557c7/src/function_evaluation/basis_functions.jl#L39-L55">source</a></section></article><p>For example, the basis set <span>$\{q, q^2, q^3\}$</span> can be defined in two ways:</p><pre><code class="language-julia hljs">using StepwiseEQL
f1 = (q, p) -&gt; q 
f2 = (q, p) -&gt; q^2 
f3 = (q, p) -&gt; q^3 
B = BasisSet(f1, f2, f3)</code></pre><pre><code class="nohighlight hljs">(::BasisSet{Tuple{var&quot;#307#308&quot;, var&quot;#309#310&quot;, var&quot;#311#312&quot;}}) (generic function with 3 methods)</code></pre><pre><code class="language-julia hljs">B = PolynomialBasis(1, 3)</code></pre><pre><code class="nohighlight hljs">(::BasisSet{Tuple{StepwiseEQL.var&quot;#52#54&quot;{Int64}, StepwiseEQL.var&quot;#52#54&quot;{Int64}, StepwiseEQL.var&quot;#52#54&quot;{Int64}}}) (generic function with 3 methods)</code></pre><p>The reason for the second argument <code>p</code> is in case you want to give better control of the scaling on the basis function&#39;s coefficients. For example, the basis set <span>$\{aq, bq^{-2}, cq^3\}$</span> can be defined as:</p><pre><code class="language-julia hljs">f1 = (q, p) -&gt; p.a * q 
f2 = (q, p) -&gt; p.b * q^(-2)
f3 = (q, p) -&gt; p.c * q^3
B = BasisSet(f1, f2, f3)</code></pre><pre><code class="nohighlight hljs">(::BasisSet{Tuple{var&quot;#313#314&quot;, var&quot;#315#316&quot;, var&quot;#317#318&quot;}}) (generic function with 3 methods)</code></pre><p>and you would then provide <code>p</code> when evaluating <code>B</code>, for example:</p><pre><code class="language-julia hljs">p = (a = 2.0, b = 3.0, c = 5.0) # same p for each basis function
B(0.2, [0.3, 0.5, 1], p)</code></pre><pre><code class="nohighlight hljs">37.66</code></pre><p>which returns <span>$\theta_1aq + \theta_2bq^{-2} + \theta_3cq^3$</span> with <span>$\theta_1 = 0.3$</span>, <span>$\theta_2 = 0.5$</span>, <span>$\theta_3 = 1$</span>, <span>$a = 2$</span>, <span>$b = 3$</span>, <span>$c = 5$</span>, and <span>$q = 0.2$</span>.</p><h2 id="Averaging-ODE-Solutions"><a class="docs-heading-anchor" href="#Averaging-ODE-Solutions">Averaging ODE Solutions</a><a id="Averaging-ODE-Solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Averaging-ODE-Solutions" title="Permalink"></a></h2><p>Usually averaging over multiple realisations from the discrete model can be handled internally by the stepwise function, but you may want to re-average for the purpose of plotting (as we do in case studies 3 and 4). For this reason, we provide <code>AveragedODESolution</code> as an exported function that you can use:</p><article class="docstring"><header><a class="docstring-binding" id="StepwiseEQL.AveragedODESolution" href="#StepwiseEQL.AveragedODESolution"><code>StepwiseEQL.AveragedODESolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AveragedODESolution{K,S}</code></pre><p>Struct representing a cell simulation averaged over many simulations. </p><p><strong>Fields</strong></p><ul><li><code>u::K</code></li></ul><p>These are the knots, storing the knots using for interpolating the solutions  at each time, where <code>u[j]</code> the knots for the <code>j</code>th time. </p><ul><li><code>t::Vector{Float64}</code></li></ul><p>The vector of times.</p><ul><li><code>q::Vector{Vector{Float64}}</code></li></ul><p>The averaged densities, with <code>q[j]</code> the averaged density at time <code>t[j]</code> and  at the corresponding knots in <code>u[j]</code>.</p><ul><li><code>cell_sol::S</code></li></ul><p>The original cell simulation.</p><p><strong>Constructor</strong></p><p>You can construct an <code>AveragedODESolution</code> using the following method:</p><pre><code class="nohighlight hljs">AveragedODESolution(
    sol::EnsembleSolution, 
    num_knots=100, 
    indices=eachindex(sol), 
    interp_fnc=LinearInterpolation, 
    stat=mean, 
    extrapolate=true
)</code></pre><p>Note that the arguments are positional arguments, not keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>sol</code></li></ul><p>The ensemble of cell solutions.</p><ul><li><code>num_knots</code></li></ul><p>The number of knots to use in the interpolant for averaging the cell solutions.  Defaults to <code>100</code>.</p><ul><li><code>indices</code></li></ul><p>The indices of the simulations to consider for averaging. Defaults to all simulations.</p><ul><li><code>interp_fnc</code></li></ul><p>A function of the form <code>(u, t)</code> that is used for averaging.  Defaults to linear interpolation from DataInterpolations.jl.</p><ul><li><code>stat</code></li></ul><p>This should be a function, or a <code>Tuple</code> of two functions with one for each endpoint, that decides the range to use  for the knots at each time step. Defaults to <code>mean</code>,  meaning the knots for a given time will span between <code>a</code> and <code>b</code>, where <code>a</code> is the average left-most cell position over each  simulation at that time, and <code>b</code> is the average right-most cell position over each simulation at that time. If, for example, <code>stat</code> were <code>(minimum, maximum)</code>, then the minimum and maximum end-positions would be used for <code>a</code> and <code>b</code>, respectively,  at the corresponding time.</p><ul><li><code>extrapolate=true</code></li></ul><p>Whether to allow for extrapolation when averaging the cell solutions. Defaults to <code>true</code>. If <code>false</code>, then when evaluating the interpolant for a given realisation and a given time, then the density for a node  is set to zero if it exceeds the right-most knot position for the given time.</p><p><strong>Output</strong></p><p>Returns the corresponding <code>AveragedODESolution</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/StepwiseEQL.jl/blob/1f3d0c965dd65a7f068318eede96b4b4625557c7/src/structs/averaged_ode_solution.jl#L2-L68">source</a></section></article><h2 id="The-Stepwise-Algorithm"><a class="docs-heading-anchor" href="#The-Stepwise-Algorithm">The Stepwise Algorithm</a><a id="The-Stepwise-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#The-Stepwise-Algorithm" title="Permalink"></a></h2><p>The entry point into our stepwise procedure is <code>stepwise_selection</code>, documented in detail below.</p><article class="docstring"><header><a class="docstring-binding" id="StepwiseEQL.stepwise_selection" href="#StepwiseEQL.stepwise_selection"><code>StepwiseEQL.stepwise_selection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stepwise_selection(cell_sol; kwargs...)</code></pre><p>Perform stepwise selection on the given cell solution <code>cell_sol</code>, given as a  <code>CellSolution</code> from EpithelialDynamics1D.jl. In the  list of keyword arguments below, the notation <code>(A/B/C/D)_Y</code>, for example,  means that there are keyword arguments <code>A_Y</code>, <code>B_Y</code>, <code>C_Y</code>, and <code>D_Y</code>.</p><p>The result returned from this function will be one of:</p><ul><li><code>EQLSolution</code></li></ul><p>This gives the solution. You can display this in the REPL to see the table of  results automatically. You can inspect the individual coefficients and other  relevant objects by inspecting the fields of the struct. For example, if  you have </p><pre><code class="nohighlight hljs">sol = stepwise_selection(cell_sol; kwargs...)</code></pre><p>then <code>sol.diffusion_theta</code> will be the set of coefficients for the diffusion  function. You can query the full list of fields by using </p><pre><code class="nohighlight hljs">propertynames(sol)</code></pre><p>or typing <code>sol.&lt;TAB&gt;</code> in the REPL (<code>&lt;TAB&gt;</code> means hit tab). We also note that if you  want to have more interactivity with the table that gets displayed in the REPL, you should  look into the <code>show</code> method for <code>EQLSolution</code>, which has signature </p><pre><code class="nohighlight hljs">Base.show(io::IO, ::MIME&quot;text/plain&quot;, eql_sol::EQLSolution;
    step_limit=6,
    crop=:horizontal,
    backend=Val(:text),
    booktabs=true,
    show_votes=false,
    show_all_loss=false,
    crayon=Crayon(bold=true, foreground=:green),
    latex_crayon=[&quot;color{blue}&quot;, &quot;textbf&quot;],
    transpose=true)</code></pre><p>For example,</p><pre><code class="nohighlight hljs">Base.show(stdout, MIME&quot;text/plain&quot;(), sol; show_votes=false, show_all_loss=false, transpose=true)</code></pre><p>prints the table without including the <code>votes</code>, only shows the complete loss function rather than also  including its individual components, and transposes the table. A LaTeX version of the table can be obtained  using <code>backend=Val(:latex)</code>, e.g. a LaTeX version of the above could be printed using</p><pre><code class="nohighlight hljs">Base.show(stdout, MIME&quot;text/plain&quot;(), sol; backend=Val(:latex), show_votes=false, show_all_loss=false, transpose=true)</code></pre><p>You can also just use </p><pre><code class="nohighlight hljs">latex_table(sol; kwargs...)</code></pre><p>to get the LaTeX format printed.</p><ul><li><code>EnsembleEQLSolution</code></li></ul><p>In this case, you have provided <code>model_samples</code> as a keyword argument and  <code>model_samples &gt; 1</code>. This struct has four fields: <code>solutions</code>, which stores  all the individual <code>EQLSolutions</code>; <code>final_loss</code>, which stores a <code>Dict</code> mapping  final vectors of active coefficients to <code>Tuples</code> of the form <code>(loss, n)</code>, where  <code>loss</code> is the loss function at that final model, and <code>n</code> is the number of times that  model was found out of the complete set of initial indicator vectors sampled;  <code>best_model</code>, which is an indicator vector which gives the model out of those found with the least loss; <code>best_model_indices</code>, which gives the indices of all solutions in <code>solutions</code> which had a  final indicator vector matching that of <code>best_model</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>(diffusion/reaction/rhs/moving_boundary)_basis::BasisSet</code></li></ul><p>The basis expansion to use for the diffusion, reaction, right-hand side, and moving boundary terms, respectively. If not provided, the functions are replaced  with the zero function. For <code>diffusion_basis</code>, a <code>BasisSet</code> is required.</p><ul><li><code>(diffusion/reaction/rhs/moving_boundary)_parameters</code></li></ul><p>The parameters to use for evaluating the corresponding basis set. The default  is <code>nothing</code>.</p><ul><li><code>(diffusion/reaction/rhs/moving_boundary)_theta</code></li></ul><p>This keyword argument indicates whether the coefficients <code>θ</code> used for evaluating the basis sets  are fixed or are to be learned, with a defualt of <code>nothing</code>. If <code>nothing</code>, then they will be learned. Otherwise, they should be  a vector of numbers indicating the coefficients <code>θ</code> to be used for the respective mechanism. For example, <code>diffusion_theta = [1.0, 0.5]</code> means that the diffusion function is evaluated with coefficients  <code>θ₁ᵈ = 1</code> and <code>θ₂ᵈ = 0.5</code>.</p><ul><li><code>threshold_tol</code></li></ul><p>The threshold tolerances to use for pruning the matrix, with a default of a zero tolerance for each  quantity. This should be a <code>NamedTuple</code> if provided, only including any of the names <code>q</code>, <code>x</code>,  <code>dt</code>, <code>dx</code>, <code>dx2</code>, <code>dx_bc</code>, and <code>dL</code>. The <code>q</code>, <code>dt</code>, <code>dx</code>, and <code>dx2</code> tolerances are used for pruning  the interior PDE, corresponding to tolerances based on the quantiles of <code>q(x, t)</code>, <code>∂q(x, t)/∂t</code>, <code>∂q(x, t)/∂x</code>, and <code>∂²q(x, t)/∂x²</code>. The <code>dx_bc</code> tolerance is used for pruning based on <code>∂q(x, t)/∂t</code> evaluated  at the boundary, and is only used for the matrix corresponding to the right-hand side boundary condition. The  <code>dL</code> tolerance is for <code>dL/dt</code>, and is only used for the matrix corresponding to the moving boundary condition.  For example, providing </p><pre><code class="nohighlight hljs">threshold_tol = (q = 0.1, dL = 0.3, x = 0.7, dx = 0.1, dx_bc = 0.05)</code></pre><p>means that the matrix for the interior problem will only include points whose densities are between the  10% and 90% density quantiles, the 10% and 90% quantiles for <code>∂q(x, t)/∂x</code>, at positions between <code>0</code> and 70% of the current leading edge for the given time. The matrix for the right-hand side boundary condition  will only include points between the 5% and 95% quantiles for <code>∂q(x, t)/∂x</code> at the boundary. The matrix  for the moving boundary condition will only include points where the velocity <code>dL/dt</code> is between the 30%  and 70% quantiles of <code>dL/dt</code>.</p><ul><li><code>mesh_points</code></li></ul><p>The number of mesh points to use for discretising the corresponding PDE. The default is <code>100</code>.</p><ul><li><code>cross_validation</code></li></ul><p>Whether to use cross-validation for selecting the model. The default is <code>false</code>.</p><ul><li><code>rng</code></li></ul><p>The random number generator to use. This defaults to the global RNG, <code>Random.default_rng()</code>.</p><ul><li><code>skip</code></li></ul><p>Indices of any coefficients that should be skipped over when deciding which terms  to include or remove. By default, this is empty</p><ul><li><code>regression</code></li></ul><p>Whether to include the regression loss in the loss function. Defaults to <code>false</code>.</p><ul><li><code>density</code></li></ul><p>Whether to include the density loss in the loss function. Defaults to <code>true</code>.</p><ul><li><code>complexity</code></li></ul><p>The complexity penalty to use for the loss function. Defaults to <code>1</code>. Use <code>0</code> if you would  not like to penalise complexity.</p><ul><li><code>loss_function</code></li></ul><p>The loss function use. Defaults to <code>default_loss(; regression, density, complexity)</code>. The loss  function should take the same form as described in <code>?default_loss</code>.</p><ul><li><code>bidirectional</code></li></ul><p>Whether to allow for steps in both directions, meaning terms can be either added or deleted at each step.  The default is <code>true</code>. If <code>false</code>, then steps can only be taken backwards.</p><ul><li><code>trials</code></li></ul><p>If <code>cross_validation</code> is true, this is the number of votes to attempt at each step of the algorithm. </p><ul><li><code>initial</code></li></ul><p>The initial set of active coefficients. The default is <code>:all</code>, meaning all terms are initially  active. If <code>:random</code>, then a random set of terms is initially active. If <code>:none</code>, then all terms are initially inactive. Otherwise, <code>initial</code> should be a vector of Booleans indicating the  initially active terms, with <code>true</code> for active and <code>false</code> for inactive. The indices should match  the flattened form of the coefficients, with the order of coefficients being <code>diffusion</code>, <code>reaction</code>,  <code>rhs</code>, and then <code>moving_boundary</code>. For example, if the basis functions are</p><pre><code class="nohighlight hljs">D(q) = θ₁ᵈϕ₁ᵈ + θ₂ᵈϕ₂ᵈ                      (diffusion)
R(q) = θ₁ʳϕ₁ʳ + θ₂ʳϕ₂ʳ + θ₃ʳϕ₃ʳ             (reaction)
H(q) = θ₁ʰϕ₁ʰ + θ₂ʰϕ₂ʰ + θ₃ʰϕ₃ʰ + θ₄ʰϕ₄ʰ    (rhs)
E(q) = θ₁ᵉϕ₁ᵉ + θ₂ᵉϕ₂ᵉ                      (moving boundary)</code></pre><p>and you want to start with <code>θ₁ᵈ</code>, <code>θ₁ʳ</code>, <code>θ₂ʳ</code>, <code>θ₂ʰ</code>, and <code>θ₂ᵉ</code> active,  then you should provide </p><pre><code class="nohighlight hljs">initial = [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1]</code></pre><ul><li><code>model_samples</code></li></ul><p>How many initial models to randomly sample when providing the results. This defaults to <code>1</code>. If <code>model_samples &gt; 1</code>, then <code>initial</code> must be <code>:random</code>. The result returned in this case  will be an <code>EnsembleEQLSolution</code>.</p><ul><li><code>use_relative_err</code></li></ul><p>Whether to use relative error (<code>true</code>) or absolute error (<code>false)</code> in the loss function summands. Defaults  to <code>true</code>.</p><ul><li><code>aggregate</code></li></ul><p>When considering an ensemble of cell solutions, <code>aggregate=true</code> indicates that the matrix constructed  should combine all the cell solutions into one matrix, and the loss function should be the sum of the loss functions for each cell solution. The default is <code>false</code>. If this is <code>false</code>, then for an ensemble of cell  solutions you must have <code>average=Val(true)</code>; if both are <code>false</code> and the cell solution is an ensemble, the call will error. </p><ul><li><code>time_range</code></li></ul><p>The time range, provided as a <code>Tuple</code> of the form <code>(tmin, tmax)</code>, to use for constructing the matrix.  The default is the complete time span that the cell simulation is performed over. </p><ul><li><code>average</code></li></ul><p>When considering an ensemble of cell solutions, <code>average=Val(true)</code> indicates that the matrix constructed  should average the solutions together into a single matrix, and the loss function should use this averaged solution,  given by an <code>AveragedODESolution</code>. The default is <code>Val(true)</code>. If this is <code>Val(false)</code>, then for an ensemble of cell  solutions you must have <code>aggregate=true</code>; if both are <code>false</code> and the cell solution is an ensemble, the call will error. </p><ul><li><code>simulation_indices</code></li></ul><p>The simulations to consider in the matrix. Only relevant if an ensemble of cell solutions is being considered. Defaults to all simulations.</p><ul><li><code>num_knots</code></li></ul><p>The number of knots to use in the interpolant for averaging the cell solutions. Only relevant if an ensemble of cell solutions is being considered. Defaults to <code>100</code>.</p><ul><li><code>avg_interp_fnc</code></li></ul><p>A function of the form <code>(u, t)</code> that is used for averaging. Only relevant if an ensemble of cell solutions is being considered. Defaults to linear interpolation from DataInterpolations.jl.</p><ul><li><code>stat</code></li></ul><p>This should be a function, or a <code>Tuple</code> of two functions with one for each endpoint, that decides the range to use  for the knots at each time step. Only relevant if an ensemble of cell solutions is being considered. Defaults to <code>mean</code>,  meaning the knots for a given time will span between <code>a</code> and <code>b</code>, where <code>a</code> is the average left-most cell position over each  simulation at that time, and <code>b</code> is the average right-most cell position over each simulation at that time. If, for example, <code>stat</code> were <code>(minimum, maximum)</code>, then the minimum and maximum end-positions would be used for <code>a</code> and <code>b</code>, respectively,  at the corresponding time.</p><ul><li><code>show_progress</code></li></ul><p>Whether to print the current step of the algorithm at each step. Defaults to <code>true</code>.</p><ul><li><code>max_steps</code></li></ul><p>Maximum number of steps to allow for the algorithm. Defaults to <code>100</code>.</p><ul><li><code>leading_edge_error</code></li></ul><p>Whether to include the leading edge error in the loss function. If this is <code>true</code>, then <code>density</code> must also be <code>true</code>. Only relevant if the cell simulation being considered is a moving boundary  problem. Defaults to <code>true</code>.</p><ul><li><code>extrapolate_pde</code></li></ul><p>If the time range is smaller than the time span of the cell simulation, then setting <code>extrapolate_pde</code> to <code>true</code> means that the loss function will still consider all saved time points, not just those within the provided  <code>time_range</code>. The default is <code>false</code>.</p><ul><li><code>num_constraint_checks</code></li></ul><p>The number of equally-spaced nodes to use between the minimum and maximum densities for constraining the diffusion term and the moving boundary term. Defaults to <code>100</code>.</p><ul><li><code>conserve_mass</code></li></ul><p>Whether to enforce conservation of mass by constraining the diffusion and moving boundary terms to be equal. Defaults to <code>false</code>.</p><ul><li><code>extrapolate_average</code></li></ul><p>Whether to allow for extrapolation when averaging the cell solutions. Only relevant if an ensemble of cell solutions is being considered. Defaults to <code>true</code>. If <code>false</code>, then when evaluating the interpolant for a given realisation and a given time, then the density for a node  is set to zero if it exceeds the right-most knot position for the given time.</p><ul><li><code>couple_rhs</code></li></ul><p>Whether to couple the boundary conditions at the right-hand side and at the moving boundary together. Only relevant if the moving boundary coefficients  are fixed. If <code>true</code>, then the matrix for the right-hand boundary condition will also include terms coming from the moving boundary,  replacing <code>∂q/∂x</code> with the right-hand side&#39;s assumed basis expansion. Defaults to <code>true</code>. If <code>false</code>, then the matrix for the right-hand boundary condition will only include terms coming from the right-hand side.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/StepwiseEQL.jl/blob/1f3d0c965dd65a7f068318eede96b4b4625557c7/src/algorithm/stepwise.jl#L1-L235">source</a></section></article><h2 id="Printing-LaTeX-Tables"><a class="docs-heading-anchor" href="#Printing-LaTeX-Tables">Printing LaTeX Tables</a><a id="Printing-LaTeX-Tables-1"></a><a class="docs-heading-anchor-permalink" href="#Printing-LaTeX-Tables" title="Permalink"></a></h2><p>From an <code>EQLSolution</code>, returned by <code>stepwise_selection</code>, you can print the LaTeX form of the table using <code>latex_table</code>:</p><article class="docstring"><header><a class="docstring-binding" id="StepwiseEQL.latex_table" href="#StepwiseEQL.latex_table"><code>StepwiseEQL.latex_table</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">latex_table(eql_sol::EQLSolution; kwargs...)</code></pre><p>Prints the <code>EQLSolution</code> <code>eql_sol</code> in LaTeX format. Keyword arguments are passed to <code>show</code>, which  has signature </p><pre><code class="nohighlight hljs">Base.show(io::IO, ::MIME&quot;text/plain&quot;, eql_sol::EQLSolution;
    step_limit=6,
    crop=:horizontal,
    backend=Val(:text),
    booktabs=true,
    show_votes=false,
    show_all_loss=false,
    crayon=Crayon(bold=true, foreground=:green),
    latex_crayon=[&quot;color{blue}&quot;, &quot;textbf&quot;],
    transpose=true)</code></pre><p>(Of course, <code>backend=Val(:latex)</code> is passed - you cannot change that.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/StepwiseEQL.jl/blob/1f3d0c965dd65a7f068318eede96b4b4625557c7/src/structs/eql_solution.jl#L457-L475">source</a></section></article><h2 id="Loss-Function"><a class="docs-heading-anchor" href="#Loss-Function">Loss Function</a><a id="Loss-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Loss-Function" title="Permalink"></a></h2><p>If you want to provide a new loss function, you can provide it as a keyword <code>loss_function</code> to <code>stepwise_selection</code>. The function that is used to construct the default loss is below for example.</p><article class="docstring"><header><a class="docstring-binding" id="StepwiseEQL.default_loss" href="#StepwiseEQL.default_loss"><code>StepwiseEQL.default_loss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">default_loss(; kwargs...)
default_loss(regression_loss, density_loss, indicators; density=true, regression=false, complexity=1)</code></pre><p>The default loss function. The first method, accepting the same keyword arguments as in the second method, returns  a function that accepts the regression loss, density loss, and indicators, and returns the total loss, evaluated  via the second method.</p><p><strong>Arguments</strong></p><ul><li><code>regression_loss</code>: The value of the regression loss.</li><li><code>density_loss</code>: The value of the density loss.</li><li><code>indicators</code>: A vector of Boolean values, indicating which the set of active coefficients.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>density=true</code>: Whether to include the density loss.</li><li><code>regression=false</code>: Whether to include the regression loss.</li><li><code>complexity=1</code>: The complexity penalty coefficient. Use <code>0</code> to disable the complexity penalty.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/StepwiseEQL.jl/blob/1f3d0c965dd65a7f068318eede96b4b4625557c7/src/individual_steps/evaluate_loss.jl#L1-L18">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../repository_structure/">« Repository Structure</a><a class="docs-footer-nextpage" href="../overview/">Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 22 August 2023 01:36">Tuesday 22 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
